import { vendorData, industryRiskProfiles, complianceFrameworks } from '../api/vendorData';
import { VendorResult } from 'calculationEngine';

// Define input parameters interface
export interface CalculationParams {
  selectedVendors: string[];
  deviceCount: number;
  yearsToProject: number;
  locations: number;
  industry: string;
  riskProfile: string;
  complianceRequirements: {
    [key: string]: boolean;
  };
  costParameters: {
    portnoxBasePricePerDevice: number;
    portnoxDiscount: number;
    fteCost: number;
    fteAllocation: number;
    maintenancePercentage: number;
    downtimeCost: number;
    riskReduction: number;
    insuranceReduction: number;
  };
  networkRequirements: {
    cloudIntegration: boolean;
    legacyDevices: boolean;
    byodSupport: boolean;
    iotSupport: boolean;
    wirelessSupport: boolean;
    remoteWork: boolean;
  };
}

// Define result interfaces
export interface VendorResult {
  vendorId: string;
  name: string;
  description: string;
  logo: string;
  badge?: string;
  badgeClass?: string;
  deployment: string;
  
  // Key metrics
  totalTco: number;
  annualTco: number;
  implementationDays: number;
  implementationCost: number;
  subscriptionCost: number;
  licenseCost: number;
  maintenanceCost: number;
  staffingCost: number;
  hardwareCost: number;
  infrastructureCost: number;
  riskReductionValue: number;
  complianceSavings: number;
  productivityGains: number;
  insuranceSavings: number;
  totalSavings: number;
  roi: number;
  paybackPeriod: number;
  securityImprovement: number;
  
  // Additional details
  costBreakdown: {
    licenses: number;
    maintenance: number;
    implementation: number;
    operations: number;
    hardware: number;
    infrastructure: number;
  };
  cumulativeCosts: {
    initial: number;
    year1: number;
    year2: number;
    year3: number;
    year4: number;
    year5: number;
  };
  
  // Operational metrics
  meanTimeToRespond: number;
  operationalImpact: string;
  managementComplexity: number;
  
  // Feature scores
  featureScores: {
    [key: string]: number;
  };
  complianceScores: {
    [key: string]: number;
  };
}

export interface ComparisonResult {
  savings: number;
  savingsPercentage: number;
  roi: number;
  paybackPeriod: number;
  implementationDifference: number;
  implementationPercentage: number;
  featureDifferences: {
    [key: string]: number;
  };
}

export interface ExecutiveSummary {
  totalSavings: number;
  savingsPercentage: number;
  paybackPeriod: number;
  riskReduction: number;
  implementationTime: number;
  topAdvantages: string[];
  topRisks: string[];
}

export interface CalculationResults {
  vendorResults: VendorResult[];
  comparisonResults: {
    [vendorId: string]: ComparisonResult;
  };
  executiveSummary: ExecutiveSummary;
  financialSummary: {
    annualSavings: number;
    fiveYearTco: number;
    costAvoidance: number;
    breakEvenPoint: number;
  };
  securitySummary: {
    riskReduction: number;
    threatPreventionImprovement: number;
    meanTimeToRespondImprovement: number;
    complianceCoverage: number;
    topSecurityBenefits: string[];
  };
  riskAssessment: {
    baselineRisk: number;
    mitigatedRisk: number;
    financialRiskReduction: number;
    complianceRiskReduction: number;
    operationalRiskReduction: number;
  };
  sensitivities: {
    deviceCountImpact: { count: number; tco: number }[];
    fteCostImpact: { cost: number; tco: number }[];
    breachProbabilityImpact: { probability: number; savings: number }[];
  };
}

// Main calculation function
export function calculateTco(params: CalculationParams): CalculationResults {
  const vendorResults: VendorResult[] = [];
  const comparisonResults: { [vendorId: string]: ComparisonResult } = {};
  
  // Calculate TCO for each selected vendor
  params.selectedVendors.forEach(vendorId => {
    const vendor = vendorData[vendorId];
    
    if (!vendor) {
      console.error(`Vendor ${vendorId} not found in data`);
      return;
    }
    
    // Portnox has special pricing with discounts
    const isPortnox = vendorId === 'portnox';
    
    // Calculate implementation costs
    const implementationDays = vendor.pricing.getImplementationDays(params.deviceCount);
    const implementationCost = vendor.pricing.getImplementationCost(params.deviceCount);
    
    // Calculate hardware costs
    const hardwareCost = vendor.pricing.getHardwareCost ? 
      vendor.pricing.getHardwareCost(params.deviceCount) : 0;
    
    // Calculate staffing costs based on FTE requirements
    const fteRequired = vendor.pricing.getFteRequired(params.deviceCount);
    const staffingCost = fteRequired * params.costParameters.fteCost * params.yearsToProject;
    
    // Calculate license costs
    let licenseCost = 0;
    let subscriptionCost = 0;
    let maintenanceCost = 0;
    
    if (vendor.pricing.model === 'subscription') {
      // For subscription-based pricing (e.g., Portnox)
      let basePricePerDevice = isPortnox ? 
        params.costParameters.portnoxBasePricePerDevice : vendor.pricing.basePrice;
      
      // Apply volume discount for Portnox
      if (isPortnox) {
        const discountPercentage = params.costParameters.portnoxDiscount / 100;
        basePricePerDevice = basePricePerDevice * (1 - discountPercentage);
      }
      
      subscriptionCost = params.deviceCount * basePricePerDevice * 12 * params.yearsToProject;
    } else {
      // For perpetual licensing (e.g., Cisco ISE)
      licenseCost = params.deviceCount * vendor.pricing.basePrice;
      
      // Calculate maintenance costs as a percentage of license costs
      let maintenancePercentage = vendor.pricing.maintenancePercentage || params.costParameters.maintenancePercentage;
      
      maintenanceCost = licenseCost * (maintenancePercentage / 100) * params.yearsToProject;
    }
    
    // Calculate infrastructure costs (power, cooling, etc.) for on-premises solutions
    const infrastructureCost = vendor.deployment === 'on-premises' ? 
      hardwareCost * 0.15 * params.yearsToProject : 0;
    
    // Get industry risk profile if selected
    const industryProfile = params.industry ? industryRiskProfiles[params.industry] : null;
    
    // Calculate risk reduction value
    let riskReductionBase = params.deviceCount * 50; // Base risk value per device
    
    // Adjust based on risk profile
    const riskMultiplier = {
      'standard': 1,
      'elevated': 1.5,
      'high': 2.5,
      'regulated': 3
    }[params.riskProfile] || 1;
    
    // Further adjust if industry profile is available
    if (industryProfile) {
      riskReductionBase *= (industryProfile.incidentProbability * 3); // Scale by industry risk
    }
    
    const riskReductionEffectiveness = vendor.pricing.riskReductionEffectiveness / 100;
    const riskReductionValue = riskReductionBase * riskMultiplier * riskReductionEffectiveness;
    
    // Calculate compliance savings
    let complianceSavings = 0;
    let complianceScores: {[key: string]: number} = {};
    
    Object.keys(params.complianceRequirements).forEach(req => {
      if (params.complianceRequirements[req] && complianceFrameworks[req]) {
        const framework = complianceFrameworks[req];
        const nacRelevance = framework.nacRelevance / 10; // Scale to 0-1
        const vendorComplianceScore = vendor.features.compliance / 10; // Scale to 0-1
        
        // Calculate compliance score for this framework
        const score = nacRelevance * vendorComplianceScore * 100; // 0-100 scale
        complianceScores[req] = score;
        
        // Calculate compliance savings based on score
        complianceSavings += 5000 * nacRelevance * vendorComplianceScore * params.yearsToProject;
      }
    });
    
    // Calculate productivity gains based on management simplicity
    const productivityGains = staffingCost * (vendor.features.managementSimplicity / 10) * 0.2;
    
    // Calculate insurance savings
    const baseInsuranceCost = params.deviceCount * 20; // Base annual insurance cost per device
    const insuranceSavings = baseInsuranceCost * (params.costParameters.insuranceReduction / 100) * params.yearsToProject;
    
    // Calculate total TCO
    const totalTco = (
      subscriptionCost + 
      licenseCost + 
      maintenanceCost + 
      implementationCost + 
      staffingCost + 
      hardwareCost + 
      infrastructureCost
    );
    
    // Calculate annual TCO
    const annualTco = totalTco / params.yearsToProject;
    
    // Calculate total benefits
    const totalSavings = riskReductionValue + complianceSavings + productivityGains + insuranceSavings;
    
    // Calculate ROI
    const roi = (totalSavings / totalTco) * 100;
    
    // Calculate payback period (in months)
    const annualBenefits = totalSavings / params.yearsToProject;
    const upfrontCosts = implementationCost + hardwareCost + (vendor.pricing.model === 'perpetual' ? licenseCost : 0);
    const paybackPeriod = upfrontCosts > 0 ? (upfrontCosts / annualBenefits) * 12 : 0;
    
    // Cost breakdown by category
    const costBreakdown = {
      licenses: licenseCost + subscriptionCost,
      maintenance: maintenanceCost,
      implementation: implementationCost,
      operations: staffingCost,
      hardware: hardwareCost,
      infrastructure: infrastructureCost
    };
    
    // Calculate cumulative costs over time
    const annualOpex = (subscriptionCost / params.yearsToProject) + 
                      (maintenanceCost / params.yearsToProject) + 
                      (staffingCost / params.yearsToProject) + 
                      (infrastructureCost / params.yearsToProject);
    
    const initialCost = implementationCost + hardwareCost + (vendor.pricing.model === 'perpetual' ? licenseCost : 0);
    
    const cumulativeCosts = {
      initial: initialCost,
      year1: initialCost + annualOpex,
      year2: initialCost + (annualOpex * 2),
      year3: initialCost + (annualOpex * 3),
      year4: initialCost + (annualOpex * 4),
      year5: initialCost + (annualOpex * 5)
    };
    
    // Calculate security improvement percentage
    const baselineSecurityLevel = 25; // No NAC baseline
    const securityImprovement = ((vendor.features.zeroTrust * 10) - baselineSecurityLevel) / baselineSecurityLevel * 100;
    
    // Extract feature scores
    const featureScores: {[key: string]: number} = {};
    Object.keys(vendor.features).forEach(feature => {
      featureScores[feature] = vendor.features[feature];
    });
    
    // Calculate management complexity (inverse of management simplicity)
    const managementComplexity = 10 - vendor.features.managementSimplicity;
    
    // Determine operational impact
    let operationalImpact = 'Low';
    if (managementComplexity > 7) {
      operationalImpact = 'High';
    } else if (managementComplexity > 4) {
      operationalImpact = 'Medium';
    }
    
    vendorResults.push({
      vendorId,
      name: vendor.name,
      description: vendor.description,
      logo: vendor.logo,
      badge: vendor.badge,
      badgeClass: vendor.badgeClass,
      deployment: vendor.deployment,
      
      totalTco,
      annualTco,
      implementationDays,
      implementationCost,
      subscriptionCost,
      licenseCost,
      maintenanceCost,
      staffingCost,
      hardwareCost,
      infrastructureCost,
      riskReductionValue,
      complianceSavings,
      productivityGains,
      insuranceSavings,
      totalSavings,
      roi,
      paybackPeriod,
      securityImprovement,
      
      costBreakdown,
      cumulativeCosts,
      
      meanTimeToRespond: vendor.pricing.meanTimeToRespond,
      operationalImpact,
      managementComplexity,
      
      featureScores,
      complianceScores
    });
  });
  
  // Calculate comparison metrics (all compared to Portnox)
  const portnoxResult = vendorResults.find(r => r.vendorId === 'portnox');
  
  if (portnoxResult) {
    vendorResults.forEach(result => {
      if (result.vendorId !== 'portnox') {
        const savings = result.totalTco - portnoxResult.totalTco;
        const savingsPercentage = (savings / result.totalTco) * 100;
        const implementationDifference = result.implementationDays - portnoxResult.implementationDays;
        const implementationPercentage = (implementationDifference / result.implementationDays) * 100;
        
        // Calculate feature differences
        const featureDifferences: {[key: string]: number} = {};
        Object.keys(portnoxResult.featureScores).forEach(feature => {
          featureDifferences[feature] = portnoxResult.featureScores[feature] - (result.featureScores[feature] || 0);
        });
        
        comparisonResults[result.vendorId] = {
          savings,
          savingsPercentage,
          roi: portnoxResult.roi - result.roi,
          paybackPeriod: result.paybackPeriod - portnoxResult.paybackPeriod,
          implementationDifference,
          implementationPercentage,
          featureDifferences
        };
      }
    });
  }
  
  // Generate executive summary metrics
  const comparisonValues = Object.values(comparisonResults);
  const avgSavings = comparisonValues.length > 0 
    ? comparisonValues.reduce((sum, val) => sum + val.savings, 0) / comparisonValues.length 
    : 0;
  
  const avgSavingsPercentage = comparisonValues.length > 0 
    ? comparisonValues.reduce((sum, val) => sum + val.savingsPercentage, 0) / comparisonValues.length 
    : 0;
  
  // Generate executive summary
  const executiveSummary = {
    totalSavings: Math.round(avgSavings),
    savingsPercentage: Math.round(avgSavingsPercentage),
    paybackPeriod: portnoxResult ? Math.round(portnoxResult.paybackPeriod) : 0,
    riskReduction: portnoxResult ? Math.round(portnoxResult.securityImprovement) : 0,
    implementationTime: portnoxResult ? portnoxResult.implementationDays : 0,
    topAdvantages: [
      'Cloud-native architecture eliminates hardware costs',
      'Rapid deployment reduces time-to-security by 75%',
      'Lower management overhead saves significant IT resources',
      'Continuous updates ensure latest security capabilities'
    ],
    topRisks: [
      'Staying with legacy NAC solutions increases breach risk',
      'Hardware-based solutions face obsolescence and upgrade cycles',
      'Complex solutions require specialized staffing and training',
      'On-premises deployments delay security improvements'
    ]
  };
  
  // Generate financial summary
  const financialSummary = {
    annualSavings: avgSavings / params.yearsToProject,
    fiveYearTco: portnoxResult ? portnoxResult.cumulativeCosts.year5 : 0,
    costAvoidance: avgSavings * 1.5, // Projected additional savings over 5 years
    breakEvenPoint: portnoxResult ? portnoxResult.paybackPeriod : 0
  };
  
  // Generate security summary
  const securitySummary = {
    riskReduction: portnoxResult ? portnoxResult.securityImprovement : 0,
    threatPreventionImprovement: portnoxResult ? portnoxResult.featureScores.threatPrevention * 10 : 0,
    meanTimeToRespondImprovement: portnoxResult && comparisonValues.length > 0 
      ? (comparisonValues.reduce((sum, val, i) => {
          const competitor = vendorResults.find(r => r.vendorId === Object.keys(comparisonResults)[i]);
          return sum + (competitor ? competitor.meanTimeToRespond - portnoxResult.meanTimeToRespond : 0);
        }, 0) / comparisonValues.length) 
      : 0,
    complianceCoverage: portnoxResult ? (portnoxResult.featureScores.compliance * 10) : 0,
    topSecurityBenefits: [
      'Real-time visibility of all network-connected devices',
      'Immediate quarantine of non-compliant devices',
      'Continuous monitoring of device security posture',
      'Automated enforcement of security policies'
    ]
  };
  
  // Generate risk assessment
  const baselineRisk = params.deviceCount * 50 * (params.riskProfile === 'high' ? 3 : params.riskProfile === 'elevated' ? 2 : 1);
  const riskAssessment = {
    baselineRisk: baselineRisk,
    mitigatedRisk: portnoxResult ? baselineRisk * (1 - (portnoxResult.featureScores.threatPrevention / 10)) : baselineRisk,
    financialRiskReduction: portnoxResult ? portnoxResult.riskReductionValue : 0,
    complianceRiskReduction: portnoxResult ? portnoxResult.complianceSavings : 0,
    operationalRiskReduction: portnoxResult ? portnoxResult.productivityGains : 0
  };
  
  // Generate sensitivity analysis
  const deviceCounts = [500, 1000, 2500, 5000, 10000];
  const fteCosts = [75000, 100000, 125000, 150000, 175000];
  const breachProbabilities = [0.1, 0.2, 0.3, 0.4, 0.5];
  
  const sensitivities = {
    deviceCountImpact: deviceCounts.map(count => {
      const tco = portnoxResult ? 
        (count / params.deviceCount) * portnoxResult.totalTco : 0;
      return { count, tco };
    }),
    fteCostImpact: fteCosts.map(cost => {
      const tco = portnoxResult ? 
        portnoxResult.totalTco - portnoxResult.staffingCost + (portnoxResult.staffingCost * (cost / params.costParameters.fteCost)) : 0;
      return { cost, tco };
    }),
    breachProbabilityImpact: breachProbabilities.map(probability => {
      const savings = portnoxResult ? 
        (probability / 0.3) * portnoxResult.riskReductionValue : 0;
      return { probability, savings };
    })
  };
  
  return {
    vendorResults,
    comparisonResults,
    executiveSummary,
    financialSummary,
    securitySummary,
    riskAssessment,
    sensitivities
  };
}
